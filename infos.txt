Confirmar se o token JWT est√° funcionando:
Fa√ßa o login via Postman:

POST http://localhost:8080/api/login

json
{
  "email": "admin@exemplo.com",
  "password": "123456"
}
Se tudo funcionar, receber√°:
json
{
  "token": "eyJ0eXAiOiJKV1QiLC..."
}

Activepieces:
Sim, o workflow ser√° executado somente quando o endpoint configurado /sgp-created for chamado via POST, por exemplo:

curl -X POST http://localhost:3000/api/v1/webhooks/sgp-created \
-H "Content-Type: application/json" \
-d '{
  "name": "SGP",
  "version": "1.0.0",
  "status": "active",
  "url": "http://localhost:8080"
}'


‚úÖ 1. D√™ permiss√£o de execu√ß√£o
No terminal, dentro da raiz do projeto (onde o setup.sh est√° salvo):
chmod +x setup.sh
Esse comando garante que o script possa ser executado como um programa.

‚úÖ 2. Execute o script com o comando desejado

./setup.sh install      # Instala depend√™ncias do backend e frontend
./setup.sh build        # Builda os containers
./setup.sh up           # Sobe os containers
./setup.sh migrate      # Roda migrations via spark
./setup.sh logs         # Ver logs dos servi√ßos

Subir os containers em background:
./setup.sh up

(Opcional) Rodar as migrations:
./setup.sh migrate

Acompanhar logs
./setup.sh logs

Veja os logs do front e confirme que o Vite subiu sem erro
./setup.sh logs -f frontend

Usando seu setup.sh
# 1) Derruba os containers e a rede
./setup.sh down

# 2) Rebuilda as imagens (backend + frontend)
./setup.sh build

# 3) Sobe tudo de volta, em background
./setup.sh up

Se voc√™ quiser que suba j√° em background (‚Äú-d‚Äù), basta trocar o √∫ltimo comando para:
./setup.sh up -d

2) Direto pelo Docker Compose
# Para parar e remover tudo (containers, rede e volumes an√¥nimos)
docker-compose -p sgp down

# Rebuild + recreate for√ßado, sem cache
docker-compose -p sgp up -d --build --force-recreate

Se voc√™ tamb√©m quiser limpar volumes persistentes (aten√ß√£o: vai apagar bancos, etc):
docker-compose -p sgp down -v
docker-compose -p sgp up -d --build --force-recreate

# desliga tudo
docker-compose -p sgp down

# recompila sem cache (ou s√≥ o frontend)
docker-compose -p sgp build --no-cache frontend

# sobe
docker-compose -p sgp up -d
Ou, se quiser for√ßar todos:

bash
Copiar c√≥digo
docker-compose -p sgp up -d --build --force-recreate

### Para rodar um seeder no CodeIgniter 4, voc√™ usa o comando:

php spark db:seed NomeDoSeeder
Por exemplo, se voc√™ tiver criado um ProjectSeeder em app/Database/Seeds/ProjectSeeder.php, basta:

php spark db:seed ProjectSeeder
Como voc√™ est√° rodando tudo em containers Docker, dentro do container do backend ficaria assim:
docker exec -it sgp-backend-1 php spark db:seed ProjectSeeder

Se quiser adicionar isso ao seu setup.sh, pode criar um caso ‚Äúseed‚Äù:
seed)
  echo "üê£ Rodando seeders..."
  docker exec -it $BACKEND_CONTAINER php spark db:seed ProjectSeeder
  ;;

Assim, voc√™ s√≥ chama:
./setup.sh seed


Para copiar manualmente o que voc√™ gerou em
backend/app/Views/assets/dist/assets

para a pasta que o Apache realmente serve em
backend/public/assets

cp -R backend/app/Views/assets/dist/assets/* backend/public/assets/

Resum√£o

Dev
cd backend/app/Views/assets
npm run dev
# ‚Üí abra http://localhost:5173

Produ√ß√£o
cd backend/app/Views/assets
npm run build
# ‚Üí isso gera dist/ + roda postbuild que copia para backend/public/assets
docker-compose -p sgp build backend
docker-compose -p sgp up -d
# ‚Üí abra http://localhost:8080


#Gerar o esqueleto CI4 em uma pasta tempor√°ria 
e copiar apenas o conte√∫do e preservando os arquivos 
Docker e o setup.sh

composer create-project codeigniter4/appstarter ci4-temp --no-dev
cp -r ci4-temp/. ./
rm -rf ci4-temp


chmod +x setup.sh
./setup.sh install
./setup.sh up


#Conjunto de comandos para descobrir todas as vers√µes e libs que seu projeto est√° usando. Por exemplo, no root do seu projeto:

# 1) Vers√£o do PHP e extens√µes
php -v
php -m

# 2) Vers√£o do CodeIgniter (CLI)
php spark --version

# 3) Depend√™ncias PHP instaladas e suas vers√µes
composer show

# 4) Vers√£o do Node.js / npm
node -v
npm -v

# 5) Pacotes front-end (Tailwind, autoprefixer, etc.)
npm list --depth=0

# 6) Vers√£o do Tailwind CLI
npx tailwindcss --version

# 7) Vers√£o do jQuery (se n√£o estiver no package.json, cheque no node_modules ou no seu c√≥digo)
grep '"jquery"' package.json

# 8) Imagens Docker e tags usadas
docker-compose images

# 9) Vers√£o do MySQL dentro do container
docker exec -it banco mysql --version


#Listagem autom√°tica, pode criar um script info.sh:

#!/usr/bin/env bash
echo "PHP:"     && php -v
echo "CI4 CLI:" && php spark --version
echo
echo "Composer deps:" 
composer show --no-ansi
echo
echo "Node/NPM:" && node -v && npm -v
echo "Front-end deps:" 
npm list --depth=0 --no-ansi
echo "Tailwind CLI:" 
npx tailwindcss --version
echo
echo "Docker images:"
docker-compose images
echo
echo "MySQL version:"
docker exec -i banco mysql --version

#D√™ permiss√£o e execute:
chmod +x info.sh
./info.sh

#Linters e fixers autom√°ticos
Se voc√™ quiser uma ferramenta que corrija estilo e potenciais bugs em PHP ou JS, normalmente instala um pacote de an√°lise est√°tica:

PHP-CS-Fixer (para estilo PHP/PSR12):
composer require --dev friendsofphp/php-cs-fixer
vendor/bin/php-cs-fixer fix

PHPCS + PHPCBF (PSR12):
composer require --dev squizlabs/php_codesniffer
vendor/bin/phpcs --standard=PSR12 app/     # s√≥ reporta
vendor/bin/phpcbf --standard=PSR12 app/   # corrige o que pode

ESLint (para seu app.js):
npm install --save-dev eslint
npx eslint "public/assets/js/**/*.js" --fix


#Varredura autom√°tica de erros e corre√ß√£o de estilo
Voc√™ j√° instalou o PHP-CS-Fixer, que faz a corre√ß√£o 
autom√°tica de estilo de c√≥digo segundo regras definidas:

Certifique-se de ter um arquivo ‚Äã.php-cs-fixer.php‚Äã na raiz (como mostramos).

Execute:
vendor/bin/php-cs-fixer fix
Isso varre todo o seu app/, public/, tests/ (conforme seu config) e aplica as regras (PSR-12, arrays curtos, imports ordenados‚Ä¶).

1 - Para ver o que mudaria, sem aplicar:
vendor/bin/php-cs-fixer fix --dry-run --diff
2 - Executando o Fixer:
Depois de criado o .php-cs-fixer.php, basta:
vendor/bin/php-cs-fixer fix
3 - S√≥ ver o que mudaria, sem aplicar:
vendor/bin/php-cs-fixer fix --dry-run --diff
4 - invocar sem config
Se, por enquanto, voc√™ s√≥ quer consertar tudo de app/ sem criar o arquivo:
vendor/bin/php-cs-fixer fix app --rules=@PSR12
Ou, para m√∫ltiplas pastas:
vendor/bin/php-cs-fixer fix app tests public --rules=@PSR12,array_syntax=[syntax=short]

#Detectar erros (tipos inv√°lidos, chamadas a m√©todos inexistentes, etc.), recomendo adicionar um analisador est√°tico como o PHPStan:

composer require --dev phpstan/phpstan
vendor/bin/phpstan analyse --level=max app tests

Resumo
# 1) Limpar cache do CI4
php spark cache:clear

# 2) Formatar/corrigir estilo de c√≥digo
vendor/bin/php-cs-fixer fix

# 3) S√≥ mostrar diffs, sem alterar
vendor/bin/php-cs-fixer fix --dry-run --diff

# 4) An√°lise est√°tica (detec√ß√£o de erros)
composer require --dev phpstan/phpstan
vendor/bin/phpstan analyse --level=max app tests


====================================================

#Integra√ß√£o cont√≠nua (CI)
Adicione ao seu pipeline de CI (GitHub Actions, GitLab CI, etc.) um job que execute, antes dos testes:
- name: Check coding style
  run: vendor/bin/php-cs-fixer fix --dry-run --diff
Assim qualquer quebra de padr√£o j√° ser√° detectada automaticamente.

Hook de pr√©-commit
Para evitar commits fora de padr√£o, use um hook Git (com husky ou simples pre-commit em .git/hooks) que rode:
vendor/bin/php-cs-fixer fix
e impe√ßa o commit se houver diffs pendentes.

An√°lise est√°tica de erros
O PHP-CS-Fixer cuida s√≥ de estilo. Para detectar problemas de tipos, chamadas a m√©todos inexistentes, vazamentos de vari√°vel, etc., instale e rode o PHPStan:

composer require --dev phpstan/phpstan
vendor/bin/phpstan analyse --level=max app

Ou o Psalm:
composer require --dev vimeo/psalm
vendor/bin/psalm --init
vendor/bin/psalm

Automatizar com Composer
No seu composer.json d√™ um alias para rodar tudo junto:
{
  "scripts": {
    "cs": "php-cs-fixer fix",
    "cs-check": "php-cs-fixer fix --dry-run --diff",
    "static": "phpstan analyse --level=7 app",
    "test": [
      "@static",
      "phpunit"
    ]
  }
}
A√≠ basta composer cs ou composer cs-check para checar, e composer test para rodar an√°lise est√°tica + testes.

Com isso seu fluxo de desenvolvimento fica:
composer install
composer cs (auto-corrige)
composer cs-check (verifica sem alterar)
composer static (detecta erros de tipo)
composer test (executa toda a su√≠te)

============================================================
# O que cada bloco phpstan.neon fazem no comando vendor/bin/phpstan analyse?
1 - memoryLimit: garante que o PHPStan tenha RAM suficiente (muito comum em n√≠veis altos ou codebases grandes).
2 - baseline: permite rodar phpstan analyse --generate-baseline uma vez, e depois ignorar tudo que foi listado ali. Bom para gradualmente adotar o PHPStan.
3 - autoload_files / bootstrapFiles: indicam ao PHPStan onde encontrar sua l√≥gica de carregamento, constantes, helpers etc.
4 - excludes_analyse: evita analisar migrations, seeds, views ‚Äî pastas que normalmente n√£o valem o esfor√ßo de tipagem est√°tica.
5 - reportUnmatchedIgnoreErrors: quando voc√™ insere coment√°rios // @phpstan-ignore-next-line, isso impede que avisos ‚Äún√£o encontrados‚Äù explodam sua build.
6 - checkMissingIterableValueType e checkMissingVarTagType: desativa alguns checks muito doloridos (voc√™ pode lig√°-los conforme for ajustando seu c√≥digo).

